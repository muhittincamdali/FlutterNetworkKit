import 'dart:io';

/// Generator for creating type-safe API client code from specifications.
///
/// This generator creates Dart code for API clients, request/response
/// models, and endpoint methods from OpenAPI or custom specifications.
///
/// Example:
/// ```dart
/// final generator = ApiGenerator(
///   outputPath: 'lib/api/generated',
///   baseClass: 'BaseApiClient',
/// );
///
/// await generator.generate(ApiSpec.fromOpenApi(openApiDoc));
/// ```
class ApiGenerator {
  /// Creates a new [ApiGenerator].
  ApiGenerator({
    required this.outputPath,
    this.baseClass = 'NetworkClient',
    this.generateModels = true,
    this.generateEndpoints = true,
    this.dateTimeFormat = DateTimeFormat.iso8601,
    this.nullSafety = true,
    this.freezed = false,
    this.jsonSerializable = true,
  });

  /// The output directory for generated files.
  final String outputPath;

  /// The base class for generated API clients.
  final String baseClass;

  /// Whether to generate model classes.
  final bool generateModels;

  /// Whether to generate endpoint methods.
  final bool generateEndpoints;

  /// The date/time format to use.
  final DateTimeFormat dateTimeFormat;

  /// Whether to generate null-safe code.
  final bool nullSafety;

  /// Whether to use Freezed for models.
  final bool freezed;

  /// Whether to use json_serializable for models.
  final bool jsonSerializable;

  /// Generates API client code from a specification.
  Future<GenerationResult> generate(ApiSpec spec) async {
    final results = <GeneratedFile>[];
    final errors = <String>[];

    try {
      // Generate models
      if (generateModels) {
        for (final model in spec.models) {
          final file = _generateModel(model);
          results.add(file);
        }
      }

      // Generate endpoint client
      if (generateEndpoints) {
        final clientFile = _generateClient(spec);
        results.add(clientFile);

        // Generate individual endpoint files
        for (final endpoint in spec.endpoints) {
          final file = _generateEndpoint(endpoint);
          results.add(file);
        }
      }

      // Generate barrel file
      results.add(_generateBarrelFile(spec, results));

      // Write files to disk
      for (final file in results) {
        await _writeFile(file);
      }

      return GenerationResult(
        files: results,
        errors: errors,
        success: true,
      );
    } catch (e) {
      errors.add(e.toString());
      return GenerationResult(
        files: results,
        errors: errors,
        success: false,
      );
    }
  }

  GeneratedFile _generateModel(ApiModel model) {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by FlutterNetworkKit');
    buffer.writeln();

    // Imports
    if (jsonSerializable) {
      buffer.writeln("import 'package:json_annotation/json_annotation.dart';");
      buffer.writeln();
      buffer.writeln("part '${_toSnakeCase(model.name)}.g.dart';");
      buffer.writeln();
    }

    // Class documentation
    if (model.description != null) {
      buffer.writeln('/// ${model.description}');
    }

    // Class annotation
    if (jsonSerializable) {
      buffer.writeln('@JsonSerializable()');
    }

    // Class declaration
    buffer.writeln('class ${model.name} {');

    // Constructor
    buffer.writeln('  /// Creates a new [${model.name}].');
    buffer.write('  const ${model.name}({');
    for (final field in model.fields) {
      final required = field.required && nullSafety ? 'required ' : '';
      buffer.write('${required}this.${field.name}, ');
    }
    buffer.writeln('});');
    buffer.writeln();

    // Factory constructor for JSON
    if (jsonSerializable) {
      buffer.writeln('  /// Creates a [${model.name}] from JSON.');
      buffer.writeln('  factory ${model.name}.fromJson(Map<String, dynamic> json) =>');
      buffer.writeln('      _\$${model.name}FromJson(json);');
      buffer.writeln();
    }

    // Fields
    for (final field in model.fields) {
      if (field.description != null) {
        buffer.writeln('  /// ${field.description}');
      }
      if (field.jsonKey != null && field.jsonKey != field.name) {
        buffer.writeln("  @JsonKey(name: '${field.jsonKey}')");
      }
      final nullableSuffix = !field.required && nullSafety ? '?' : '';
      buffer.writeln('  final ${field.type}$nullableSuffix ${field.name};');
      buffer.writeln();
    }

    // toJson method
    if (jsonSerializable) {
      buffer.writeln('  /// Converts this [${model.name}] to JSON.');
      buffer.writeln('  Map<String, dynamic> toJson() => _\$${model.name}ToJson(this);');
      buffer.writeln();
    }

    // copyWith method
    buffer.writeln('  /// Creates a copy with the specified overrides.');
    buffer.write('  ${model.name} copyWith({');
    for (final field in model.fields) {
      buffer.write('${field.type}? ${field.name}, ');
    }
    buffer.writeln('}) {');
    buffer.write('    return ${model.name}(');
    for (final field in model.fields) {
      buffer.write('${field.name}: ${field.name} ?? this.${field.name}, ');
    }
    buffer.writeln(');');
    buffer.writeln('  }');

    // toString
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.write("  String toString() => '${model.name}(");
    for (var i = 0; i < model.fields.length; i++) {
      final field = model.fields[i];
      buffer.write('${field.name}: \$${field.name}');
      if (i < model.fields.length - 1) buffer.write(', ');
    }
    buffer.writeln(")';");

    buffer.writeln('}');

    return GeneratedFile(
      name: '${_toSnakeCase(model.name)}.dart',
      content: buffer.toString(),
      type: GeneratedFileType.model,
    );
  }

  GeneratedFile _generateClient(ApiSpec spec) {
    final buffer = StringBuffer();

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by FlutterNetworkKit');
    buffer.writeln();

    buffer.writeln("import 'package:flutter_network_kit/flutter_network_kit.dart';");
    buffer.writeln();

    // Import models
    for (final model in spec.models) {
      buffer.writeln("import '${_toSnakeCase(model.name)}.dart';");
    }
    buffer.writeln();

    // Class documentation
    buffer.writeln('/// Generated API client for ${spec.name}.');
    if (spec.description != null) {
      buffer.writeln('///');
      buffer.writeln('/// ${spec.description}');
    }
    buffer.writeln('class ${spec.name}ApiClient {');

    // Constructor
    buffer.writeln('  /// Creates a new [${spec.name}ApiClient].');
    buffer.writeln('  ${spec.name}ApiClient({required this.client});');
    buffer.writeln();

    // Fields
    buffer.writeln('  /// The underlying network client.');
    buffer.writeln('  final $baseClass client;');
    buffer.writeln();

    // Generate endpoint methods
    for (final endpoint in spec.endpoints) {
      _generateEndpointMethod(buffer, endpoint);
    }

    buffer.writeln('}');

    return GeneratedFile(
      name: '${_toSnakeCase(spec.name)}_api_client.dart',
      content: buffer.toString(),
      type: GeneratedFileType.client,
    );
  }

  void _generateEndpointMethod(StringBuffer buffer, ApiEndpoint endpoint) {
    // Documentation
    buffer.writeln('  /// ${endpoint.description ?? endpoint.name}');
    if (endpoint.parameters.isNotEmpty) {
      buffer.writeln('  ///');
      for (final param in endpoint.parameters) {
        buffer.writeln('  /// [${param.name}] - ${param.description ?? param.name}');
      }
    }

    // Method signature
    final returnType = endpoint.responseType ?? 'dynamic';
    buffer.write('  Future<NetworkResponse<$returnType>> ${endpoint.name}(');

    // Parameters
    final requiredParams = endpoint.parameters.where((p) => p.required).toList();
    final optionalParams = endpoint.parameters.where((p) => !p.required).toList();

    for (final param in requiredParams) {
      buffer.write('${param.type} ${param.name}, ');
    }

    if (optionalParams.isNotEmpty) {
      buffer.write('{');
      for (final param in optionalParams) {
        buffer.write('${param.type}? ${param.name}, ');
      }
      buffer.write('}');
    }

    buffer.writeln(') async {');

    // Method body
    final method = endpoint.method.toLowerCase();
    buffer.writeln("    return client.$method<$returnType>(");
    buffer.writeln("      '${endpoint.path}',");

    // Query parameters
    final queryParams = endpoint.parameters.where((p) => p.location == 'query').toList();
    if (queryParams.isNotEmpty) {
      buffer.writeln('      queryParameters: {');
      for (final param in queryParams) {
        buffer.writeln("        if (${param.name} != null) '${param.name}': ${param.name},");
      }
      buffer.writeln('      },');
    }

    // Body
    final bodyParam = endpoint.parameters.where((p) => p.location == 'body').firstOrNull;
    if (bodyParam != null) {
      buffer.writeln('      body: ${bodyParam.name},');
    }

    // Decoder
    if (endpoint.responseType != null && endpoint.responseType != 'dynamic') {
      buffer.writeln('      decoder: (data) => ${endpoint.responseType}.fromJson(data as Map<String, dynamic>),');
    }

    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
  }

  GeneratedFile _generateEndpoint(ApiEndpoint endpoint) {
    // Individual endpoint files could contain additional logic
    final buffer = StringBuffer();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Endpoint: ${endpoint.name}');
    buffer.writeln();
    buffer.writeln('// This file is reserved for endpoint-specific extensions');

    return GeneratedFile(
      name: '${_toSnakeCase(endpoint.name)}_endpoint.dart',
      content: buffer.toString(),
      type: GeneratedFileType.endpoint,
    );
  }

  GeneratedFile _generateBarrelFile(ApiSpec spec, List<GeneratedFile> files) {
    final buffer = StringBuffer();

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Barrel file for ${spec.name} API');
    buffer.writeln();

    for (final file in files.where((f) => f.type != GeneratedFileType.barrel)) {
      buffer.writeln("export '${file.name}';");
    }

    return GeneratedFile(
      name: '${_toSnakeCase(spec.name)}_api.dart',
      content: buffer.toString(),
      type: GeneratedFileType.barrel,
    );
  }

  Future<void> _writeFile(GeneratedFile file) async {
    final directory = Directory(outputPath);
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }

    final filePath = '$outputPath/${file.name}';
    await File(filePath).writeAsString(file.content);
  }

  String _toSnakeCase(String input) {
    return input
        .replaceAllMapped(RegExp(r'[A-Z]'), (m) => '_${m.group(0)!.toLowerCase()}')
        .replaceFirst('_', '');
  }
}

/// Date/time format for generated code.
enum DateTimeFormat {
  /// ISO 8601 format.
  iso8601,

  /// Unix timestamp in seconds.
  unixSeconds,

  /// Unix timestamp in milliseconds.
  unixMillis,
}

/// API specification for code generation.
class ApiSpec {
  const ApiSpec({
    required this.name,
    this.description,
    required this.models,
    required this.endpoints,
    this.baseUrl,
  });

  final String name;
  final String? description;
  final List<ApiModel> models;
  final List<ApiEndpoint> endpoints;
  final String? baseUrl;
}

/// Model definition for code generation.
class ApiModel {
  const ApiModel({
    required this.name,
    this.description,
    required this.fields,
  });

  final String name;
  final String? description;
  final List<ApiField> fields;
}

/// Field definition for model generation.
class ApiField {
  const ApiField({
    required this.name,
    required this.type,
    this.jsonKey,
    this.description,
    this.required = true,
    this.defaultValue,
  });

  final String name;
  final String type;
  final String? jsonKey;
  final String? description;
  final bool required;
  final String? defaultValue;
}

/// Endpoint definition for code generation.
class ApiEndpoint {
  const ApiEndpoint({
    required this.name,
    required this.method,
    required this.path,
    this.description,
    this.parameters = const [],
    this.responseType,
  });

  final String name;
  final String method;
  final String path;
  final String? description;
  final List<ApiParameter> parameters;
  final String? responseType;
}

/// Parameter definition for endpoint generation.
class ApiParameter {
  const ApiParameter({
    required this.name,
    required this.type,
    this.location = 'query',
    this.description,
    this.required = false,
  });

  final String name;
  final String type;
  final String location;
  final String? description;
  final bool required;
}

/// Generated file information.
class GeneratedFile {
  const GeneratedFile({
    required this.name,
    required this.content,
    required this.type,
  });

  final String name;
  final String content;
  final GeneratedFileType type;
}

/// Type of generated file.
enum GeneratedFileType {
  model,
  client,
  endpoint,
  barrel,
}

/// Result of code generation.
class GenerationResult {
  const GenerationResult({
    required this.files,
    required this.errors,
    required this.success,
  });

  final List<GeneratedFile> files;
  final List<String> errors;
  final bool success;

  int get fileCount => files.length;
  int get errorCount => errors.length;
}
